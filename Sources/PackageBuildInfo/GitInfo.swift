/////
////  GitInfo.swift
///   Copyright Â© 2022 Dmitriy Borovikov. All rights reserved.
//

import Foundation

final class GitInfoCoder {
    private let git: URL
    private let gitDirectory: URL
    private let outputFile: URL?

    private struct GitInfo {
        var isDirty = true
        var date = ""
        var count = "0"
        var branch = "nil"
        var countSince = "0"
        var tag: String?
        var digest: String?
    }

    init?(gitDirectory: URL, outputFile: URL?) {
        self.gitDirectory = gitDirectory
        self.outputFile = outputFile
        guard let git = GitInfoCoder.searchGit() else {
            print("Git not found in PATH")
            return nil
        }
        self.git = git
    }

    private static func searchGit() -> URL? {
        let pathList = ProcessInfo.processInfo.environment["PATH"] ?? "/usr/bin"

        for path in pathList.split(separator: ":") {
            let gitURL = URL(fileURLWithPath: String(path)).appendingPathComponent("git")
            if let res = try? gitURL.resourceValues(forKeys: [.isExecutableKey]),
               res.isExecutable ?? false
            {
                return gitURL
            }
        }
        return nil
    }

    private func runGit(command: String) throws -> (exitCode: Int32, output: String) {
        let process = Process()
        process.executableURL = git
        process.currentDirectoryURL = gitDirectory

        let stdinPipe = Pipe()
        let stdErrPipe = Pipe()
        process.standardOutput = stdinPipe
        process.standardError = stdErrPipe
        process.arguments = command.split(separator: " ").map { String($0) }
        try process.run()
        process.waitUntilExit()
        let status = process.terminationStatus

        let data = try stdinPipe.fileHandleForReading.readToEnd() ?? Data()
        let output = (String(data: data, encoding: .utf8) ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
        return (exitCode: status, output: output)
    }

    private func getInfo() throws -> GitInfo {
        var info = GitInfo()

        info.date = "\(Date().timeIntervalSince1970)"
        var (exitCode, output) = try runGit(command: "status --porcelain -uno")
        guard exitCode == 0 else {
            print("Warning: not a git repository")
            return info
        }
        if output.isEmpty {
            info.isDirty = false
        }
        (exitCode, output) = try runGit(command: "describe --tags --abbrev=0")
        if exitCode == 0, !output.isEmpty {
            info.tag = "\"\(output)\""
            (exitCode, output) = try runGit(command: "rev-list \(output)..HEAD --count")
            if exitCode == 0, !output.isEmpty {
                info.countSince = output
            }
        }
        
        (exitCode, output) = try runGit(command: "branch --show-current")
        if exitCode == 0, !output.isEmpty {
            info.branch = "\"\(output)\""
        }
        (exitCode, output) = try runGit(command: "show -s --format=%H:%ct")
        if exitCode == 0, !output.isEmpty {
            let parts = output.split(separator: ":").map { String($0) }
            info.digest = parts[0]
            info.date = parts[1]
        }
        (exitCode, output) = try runGit(command: "rev-list --count HEAD")
        if exitCode == 0, !output.isEmpty {
            info.count = output
        }
        return info
    }
    
    private func generateCode(_ info: GitInfo) -> String {
        let timeZone = TimeZone.current.secondsFromGMT()

        var digestS = "["
        if var digest = info.digest {
            for _ in 0..<digest.count / 2 {
                digestS += "0x" + digest.prefix(2) + ", "
                digest.removeFirst(2)
            }
            digestS.removeLast(2)
        }
        digestS += "]"

        let code = """
        /////
        //// Package Build info
        ///  Code generated by PackageBuildInfo. DO NOT EDIT.
        //
        import Foundation

        public struct PackageBuild {
            let isDirty: Bool       // Dirty build - git directory is't clean.
            let timeStamp: Date     // Time of last commit
            let timeZone: TimeZone  // Time Zone
            let count: Int          // Total commit count
            let tag: String?        // Tag, if exist
            let countSince: Int     // Commit count since tag
            let branch: String?     // Git branch name
            let digest: [UInt8]     // Latest commit sha1 digest (20 bytes)

            var commit: String {
                digest.reduce("") { $0 + String(format: "%02x", $1) }
            }
            static let info = PackageBuild(
                                      isDirty: \(info.isDirty ? "true" : "false"),
                                      timeStamp: Date(timeIntervalSince1970: \(info.date)),
                                      timeZone: TimeZone(secondsFromGMT: \(timeZone))!,
                                      count: \(info.count),
                                      tag: \(info.tag ?? "nil"),
                                      countSince: \(info.countSince),
                                      branch: \(info.branch),
                                      digest: \(digestS))
        }
        """
        return code
    }
    
    func codegen() {
        do {
            let info = try getInfo()
            let code = generateCode(info)
            if let outputFile = outputFile {
                try code.write(to: outputFile, atomically: true, encoding: .utf8)
            } else {
                print(code)
            }
        } catch  {
            print(error.localizedDescription)
            exit(1)
        }
    }
}
